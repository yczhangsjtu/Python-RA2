#! This file is generated by ChatGPT and is not
#  working for now. Need going through and revision.

import struct

#define MAX_FILE_NAME 256

MAX_FILE_NAME = 256

# typedef unsigned char BYTE;
# typedef short int WORD;
# typedef int LONGINT;

BYTE = 1
WORD = 2
LONGINT = 4


# typedef struct Color{
# 	BYTE c[4];
# } Color;

class Color:
    def __init__(self, r, g, b, a):
        self.c = [r, g, b, a]

# typedef struct FileHeader{
# 	WORD check;
# 	WORD width;
# 	WORD height;
# 	WORD num;
# } FileHeader;

class FileHeader:
    def __init__(self, check, width, height, num):
        self.check = check
        self.width = width
        self.height = height
        self.num = num

# typedef struct ImageHeader{
# 	WORD x,y,w,h;
# 	BYTE compression;
# 	BYTE align[3];
# 	Color transparent;
# 	LONGINT zero,offset;
# } ImageHeader;

class ImageHeader:
    def __init__(self, x, y, w, h, compression, align0, align1, align2, transparent0, transparent1, transparent2, transparent3, zero, offset):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.compression = compression
        self.align = [align0, align1, align2]
        self.transparent = Color(transparent0, transparent1, transparent2, transparent3)
        self.zero = zero
        self.offset = offset

# typedef struct ImageData{
# 	ImageHeader header;
# 	BYTE * data;
# } ImageData;

class ImageData:
    def __init__(self, header):
        self.header = header
        self.data = None

# typedef struct Image{
# 	LONGINT w,h;
# 	BYTE *data;
# } Image;

class Image:
    def __init__(self):
        self.w = 0
        self.h = 0
        self.data = None

# void allocImageData(ImageData *imageData)
# {
# 	LONGINT size = imageData->header.w * imageData->header.h;
# 	imageData->data = (BYTE*)malloc(size * sizeof(LONGINT));
# }

def allocImageData(imageData):
    size = imageData.header.w * imageData.header.h
    imageData.data = [0] * (size * LONGINT)

# void decompress1(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
# 	memcpy(dst,src,w*h);
# }

def decompress1(dst, src, w, h):
    dst[:w*h] = src[:w*h]

# void decompress2(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
	
# }

def decompress2(dst, src, w, h):
    pass

# void decompress3(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
def decompress3(dst, src, w, h):
# 	BYTE *psrc = src, *pdst = dst;
    psrc = 0
    pdst = 0
# 	BYTE v;
    v = 0
# 	WORD pos, count, x, y, i;
    pos = 0
    count = 0
    x = 0
    y = 0
    i = 0
# 	for(y = 0; y < h; y++)
# 	{
    for y in range(h):
# 		pos = *((WORD*)psrc);
# 		count = pos-2;
# 		psrc += 2;
# 		x = 0;
        pos = struct.unpack_from('<H', src, psrc)[0]
        count = pos - 2
        psrc += 2
        x = 0
# 		for(i = 0; i < count; i++)
# 		{
        skip_next = False
        for i in range(count):
            if skip_next:
                skip_next = False
                continue
# 			v = *psrc++;
            v = src[psrc]
            psrc += 1
# 			if(v)
# 			{
            if v != 0:
# 				*pdst++ = v;
# 				x++;
                dst[pdst] = v
                pdst += 1
                x += 1
# 			}
# 			else
# 			{
            else:
# 				v = *psrc++;
# 				i++;
                v = src[psrc]
                psrc += 1
                skip_next = True
# 				while(v > 0 && x < w)
# 				{
                while v > 0 and x < w:
# 					*pdst++ = 0;
# 					x++;
# 					v--;
                    dst[pdst] = 0
                    pdst += 1
                    x += 1
                    v -= 1
# 				}
# 			}
# 		}
# 		assert(x == w);
# 	}
# }






# BYTE defaultPalatte[][3] =
# {
# 	{0x00,0x00,0x00}, {0x2a,0x00,0x2a}, {0x00,0x2a,0x2a}, {0x00,0x2a,0x00},
# 	{0x15,0x3f,0x15}, {0x3f,0x3f,0x15}, {0x3f,0x15,0x15}, {0x2a,0x15,0x00},
# 	{0x2a,0x00,0x00}, {0x15,0x3f,0x3f}, {0x14,0x14,0x3f}, {0x00,0x00,0x2a},
# 	{0x00,0x00,0x00}, {0x15,0x15,0x15}, {0x2a,0x2a,0x2a}, {0x3f,0x3f,0x3f},
# 	{0x3f,0x00,0x00}, {0x3b,0x00,0x00}, {0x37,0x00,0x00}, {0x34,0x00,0x00},
# 	{0x30,0x00,0x00}, {0x2c,0x00,0x00}, {0x29,0x00,0x00}, {0x25,0x00,0x00},
# 	{0x21,0x00,0x00}, {0x1e,0x00,0x00}, {0x1a,0x00,0x00}, {0x16,0x00,0x00},
# 	{0x13,0x00,0x00}, {0x0f,0x00,0x00}, {0x0b,0x00,0x00}, {0x08,0x00,0x00},
# 	{0x3f,0x3f,0x3f}, {0x3d,0x3d,0x3d}, {0x3b,0x3b,0x3b}, {0x38,0x38,0x38},
# 	{0x36,0x36,0x36}, {0x34,0x34,0x34}, {0x32,0x32,0x32}, {0x30,0x30,0x30},
# 	{0x2e,0x2e,0x2e}, {0x2c,0x2c,0x2c}, {0x2a,0x2a,0x2a}, {0x28,0x28,0x28},
# 	{0x26,0x26,0x26}, {0x24,0x24,0x24}, {0x22,0x22,0x22}, {0x20,0x20,0x20},
# 	{0x1e,0x1e,0x1e}, {0x1c,0x1c,0x1c}, {0x1a,0x1a,0x1a}, {0x18,0x18,0x18},
# 	{0x15,0x15,0x15}, {0x13,0x13,0x13}, {0x11,0x11,0x11}, {0x0f,0x0f,0x0f},
# 	{0x0d,0x0d,0x0d}, {0x0b,0x0b,0x0b}, {0x09,0x09,0x09}, {0x07,0x07,0x07},
# 	{0x05,0x05,0x05}, {0x03,0x03,0x03}, {0x01,0x01,0x01}, {0x00,0x00,0x00},
# 	{0x34,0x34,0x2e}, {0x31,0x31,0x2b}, {0x2e,0x2e,0x28}, {0x2b,0x2b,0x25},
# 	{0x28,0x28,0x22}, {0x25,0x25,0x1f}, {0x22,0x22,0x1c}, {0x1f,0x1f,0x19},
# 	{0x1c,0x1c,0x16}, {0x19,0x19,0x13}, {0x16,0x16,0x10}, {0x13,0x13,0x0d},
# 	{0x10,0x10,0x0a}, {0x0d,0x0d,0x07}, {0x0a,0x0a,0x04}, {0x07,0x07,0x01},
# 	{0x37,0x37,0x3d}, {0x34,0x34,0x3a}, {0x31,0x31,0x37}, {0x2e,0x2e,0x34},
# 	{0x2b,0x2b,0x31}, {0x28,0x28,0x2e}, {0x25,0x25,0x2b}, {0x22,0x22,0x28},
# 	{0x1f,0x1f,0x25}, {0x1c,0x1c,0x22}, {0x19,0x19,0x1f}, {0x16,0x16,0x1c},
# 	{0x13,0x13,0x19}, {0x10,0x10,0x16}, {0x0d,0x0d,0x13}, {0x0a,0x0a,0x10},
# 	{0x3b,0x2f,0x2b}, {0x38,0x2c,0x28}, {0x35,0x29,0x25}, {0x32,0x26,0x22},
# 	{0x2f,0x23,0x1f}, {0x2c,0x20,0x1c}, {0x29,0x1d,0x19}, {0x26,0x1a,0x16},
# 	{0x23,0x17,0x13}, {0x20,0x14,0x10}, {0x1d,0x11,0x0d}, {0x1a,0x0e,0x0a},
# 	{0x17,0x0b,0x07}, {0x14,0x08,0x04}, {0x11,0x05,0x01}, {0x0d,0x01,0x00},
# 	{0x22,0x20,0x16}, {0x20,0x1e,0x15}, {0x1e,0x1d,0x14}, {0x1d,0x1b,0x13},
# 	{0x1c,0x1a,0x12}, {0x1a,0x18,0x11}, {0x18,0x16,0x10}, {0x16,0x14,0x0f},
# 	{0x14,0x12,0x0e}, {0x12,0x10,0x0c}, {0x0e,0x0e,0x0a}, {0x0c,0x0c,0x09},
# 	{0x0b,0x0b,0x08}, {0x0a,0x0a,0x07}, {0x08,0x08,0x05}, {0x06,0x06,0x03},
# 	{0x35,0x2f,0x1e}, {0x33,0x2d,0x1c}, {0x31,0x2b,0x1c}, {0x2f,0x29,0x1a},
# 	{0x2b,0x27,0x1a}, {0x29,0x25,0x18}, {0x27,0x23,0x16}, {0x25,0x21,0x14},
# 	{0x23,0x1e,0x14}, {0x21,0x1c,0x12}, {0x1e,0x1a,0x10}, {0x1c,0x18,0x0f},
# 	{0x1a,0x18,0x12}, {0x19,0x17,0x11}, {0x18,0x16,0x10}, {0x17,0x15,0x10},
# 	{0x2f,0x24,0x0f}, {0x2c,0x23,0x0e}, {0x29,0x21,0x0e}, {0x26,0x1e,0x0e},
# 	{0x23,0x1c,0x0e}, {0x21,0x1b,0x0e}, {0x1e,0x19,0x0e}, {0x1c,0x17,0x0c},
# 	{0x1b,0x16,0x0b}, {0x1a,0x15,0x0b}, {0x19,0x14,0x0a}, {0x18,0x13,0x0a},
# 	{0x17,0x12,0x0a}, {0x16,0x12,0x0a}, {0x15,0x11,0x0a}, {0x13,0x10,0x0a},
# 	{0x11,0x0e,0x09}, {0x0f,0x0d,0x08}, {0x0d,0x0b,0x08}, {0x0b,0x09,0x07},
# 	{0x0a,0x08,0x07}, {0x09,0x07,0x07}, {0x08,0x07,0x07}, {0x06,0x06,0x06},
# 	{0x22,0x2f,0x1d}, {0x1d,0x2b,0x18}, {0x18,0x27,0x13}, {0x14,0x24,0x0f},
# 	{0x11,0x20,0x0b}, {0x0d,0x1d,0x08}, {0x0a,0x19,0x05}, {0x08,0x16,0x03},
# 	{0x3f,0x3f,0x1c}, {0x3f,0x3d,0x1b}, {0x3f,0x3a,0x1a}, {0x3f,0x38,0x19},
# 	{0x3f,0x36,0x18}, {0x3f,0x34,0x18}, {0x3f,0x30,0x16}, {0x3d,0x2d,0x14},
# 	{0x3b,0x2b,0x12}, {0x39,0x25,0x0c}, {0x35,0x1e,0x04}, {0x31,0x18,0x00},
# 	{0x2d,0x12,0x00}, {0x29,0x0e,0x00}, {0x26,0x0a,0x00}, {0x22,0x06,0x00},
# 	{0x2c,0x2c,0x3f}, {0x25,0x25,0x39}, {0x1f,0x1f,0x33}, {0x1a,0x1a,0x2d},
# 	{0x15,0x15,0x27}, {0x10,0x10,0x21}, {0x0c,0x0c,0x1b}, {0x09,0x09,0x16},
# 	{0x3f,0x00,0x00}, {0x34,0x00,0x00}, {0x29,0x00,0x00}, {0x1f,0x00,0x00},
# 	{0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f},
# 	{0x37,0x3d,0x3f}, {0x34,0x3b,0x3e}, {0x33,0x39,0x3d}, {0x30,0x37,0x3d},
# 	{0x2e,0x35,0x3c}, {0x2c,0x33,0x3b}, {0x2a,0x31,0x3b}, {0x28,0x2f,0x3a},
# 	{0x27,0x2c,0x39}, {0x25,0x2a,0x39}, {0x22,0x26,0x34}, {0x1f,0x23,0x30},
# 	{0x1c,0x20,0x2b}, {0x19,0x1c,0x27}, {0x16,0x19,0x22}, {0x13,0x16,0x1e},
# 	{0x39,0x3c,0x3f}, {0x35,0x39,0x3d}, {0x32,0x36,0x3b}, {0x2f,0x34,0x39},
# 	{0x2b,0x31,0x37}, {0x28,0x2f,0x35}, {0x26,0x2d,0x33}, {0x23,0x2b,0x31},
# 	{0x21,0x29,0x31}, {0x1e,0x28,0x2f}, {0x1c,0x27,0x2e}, {0x1a,0x25,0x2d},
# 	{0x18,0x24,0x2c}, {0x15,0x23,0x2b}, {0x14,0x22,0x2a}, {0x12,0x21,0x29},
# 	{0x3f,0x3f,0x3f}, {0x31,0x31,0x32}, {0x28,0x28,0x29}, {0x20,0x20,0x21},
# 	{0x18,0x18,0x19}, {0x00,0x32,0x00}, {0x3f,0x3f,0x00}, {0x3f,0x2f,0x00},
# 	{0x3f,0x1f,0x00}, {0x3f,0x00,0x00}, {0x2f,0x00,0x00}, {0x33,0x33,0x3f},
# 	{0x26,0x26,0x3f}, {0x19,0x19,0x3f}, {0x00,0x00,0x3f}, {0x3f,0x3f,0x3f}
# };

defaultPalatte = [
	(0x00,0x00,0x00), (0x2a,0x00,0x2a), (0x00,0x2a,0x2a), (0x00,0x2a,0x00),
	(0x15,0x3f,0x15), (0x3f,0x3f,0x15), (0x3f,0x15,0x15), (0x2a,0x15,0x00),
	(0x2a,0x00,0x00), (0x15,0x3f,0x3f), (0x14,0x14,0x3f), (0x00,0x00,0x2a),
	(0x00,0x00,0x00), (0x15,0x15,0x15), (0x2a,0x2a,0x2a), (0x3f,0x3f,0x3f),
	(0x3f,0x00,0x00), (0x3b,0x00,0x00), (0x37,0x00,0x00), (0x34,0x00,0x00),
	(0x30,0x00,0x00), (0x2c,0x00,0x00), (0x29,0x00,0x00), (0x25,0x00,0x00),
	(0x21,0x00,0x00), (0x1e,0x00,0x00), (0x1a,0x00,0x00), (0x16,0x00,0x00),
	(0x13,0x00,0x00), (0x0f,0x00,0x00), (0x0b,0x00,0x00), (0x08,0x00,0x00),
	(0x3f,0x3f,0x3f), (0x3d,0x3d,0x3d), (0x3b,0x3b,0x3b), (0x38,0x38,0x38),
	(0x36,0x36,0x36), (0x34,0x34,0x34), (0x32,0x32,0x32), (0x30,0x30,0x30),
	(0x2e,0x2e,0x2e), (0x2c,0x2c,0x2c), (0x2a,0x2a,0x2a), (0x28,0x28,0x28),
	(0x26,0x26,0x26), (0x24,0x24,0x24), (0x22,0x22,0x22), (0x20,0x20,0x20),
	(0x1e,0x1e,0x1e), (0x1c,0x1c,0x1c), (0x1a,0x1a,0x1a), (0x18,0x18,0x18),
	(0x15,0x15,0x15), (0x13,0x13,0x13), (0x11,0x11,0x11), (0x0f,0x0f,0x0f),
	(0x0d,0x0d,0x0d), (0x0b,0x0b,0x0b), (0x09,0x09,0x09), (0x07,0x07,0x07),
	(0x05,0x05,0x05), (0x03,0x03,0x03), (0x01,0x01,0x01), (0x00,0x00,0x00),
	(0x34,0x34,0x2e), (0x31,0x31,0x2b), (0x2e,0x2e,0x28), (0x2b,0x2b,0x25),
	(0x28,0x28,0x22), (0x25,0x25,0x1f), (0x22,0x22,0x1c), (0x1f,0x1f,0x19),
	(0x1c,0x1c,0x16), (0x19,0x19,0x13), (0x16,0x16,0x10), (0x13,0x13,0x0d),
	(0x10,0x10,0x0a), (0x0d,0x0d,0x07), (0x0a,0x0a,0x04), (0x07,0x07,0x01),
	(0x37,0x37,0x3d), (0x34,0x34,0x3a), (0x31,0x31,0x37), (0x2e,0x2e,0x34),
	(0x2b,0x2b,0x31), (0x28,0x28,0x2e), (0x25,0x25,0x2b), (0x22,0x22,0x28),
	(0x1f,0x1f,0x25), (0x1c,0x1c,0x22), (0x19,0x19,0x1f), (0x16,0x16,0x1c),
	(0x13,0x13,0x19), (0x10,0x10,0x16), (0x0d,0x0d,0x13), (0x0a,0x0a,0x10),
	(0x3b,0x2f,0x2b), (0x38,0x2c,0x28), (0x35,0x29,0x25), (0x32,0x26,0x22),
	(0x2f,0x23,0x1f), (0x2c,0x20,0x1c), (0x29,0x1d,0x19), (0x26,0x1a,0x16),
	(0x23,0x17,0x13), (0x20,0x14,0x10), (0x1d,0x11,0x0d), (0x1a,0x0e,0x0a),
	(0x17,0x0b,0x07), (0x14,0x08,0x04), (0x11,0x05,0x01), (0x0d,0x01,0x00),
	(0x22,0x20,0x16), (0x20,0x1e,0x15), (0x1e,0x1d,0x14), (0x1d,0x1b,0x13),
	(0x1c,0x1a,0x12), (0x1a,0x18,0x11), (0x18,0x16,0x10), (0x16,0x14,0x0f),
	(0x14,0x12,0x0e), (0x12,0x10,0x0c), (0x0e,0x0e,0x0a), (0x0c,0x0c,0x09),
	(0x0b,0x0b,0x08), (0x0a,0x0a,0x07), (0x08,0x08,0x05), (0x06,0x06,0x03),
	(0x35,0x2f,0x1e), (0x33,0x2d,0x1c), (0x31,0x2b,0x1c), (0x2f,0x29,0x1a),
	(0x2b,0x27,0x1a), (0x29,0x25,0x18), (0x27,0x23,0x16), (0x25,0x21,0x14),
	(0x23,0x1e,0x14), (0x21,0x1c,0x12), (0x1e,0x1a,0x10), (0x1c,0x18,0x0f),
	(0x1a,0x18,0x12), (0x19,0x17,0x11), (0x18,0x16,0x10), (0x17,0x15,0x10),
	(0x2f,0x24,0x0f), (0x2c,0x23,0x0e), (0x29,0x21,0x0e), (0x26,0x1e,0x0e),
	(0x23,0x1c,0x0e), (0x21,0x1b,0x0e), (0x1e,0x19,0x0e), (0x1c,0x17,0x0c),
	(0x1b,0x16,0x0b), (0x1a,0x15,0x0b), (0x19,0x14,0x0a), (0x18,0x13,0x0a),
	(0x17,0x12,0x0a), (0x16,0x12,0x0a), (0x15,0x11,0x0a), (0x13,0x10,0x0a),
	(0x11,0x0e,0x09), (0x0f,0x0d,0x08), (0x0d,0x0b,0x08), (0x0b,0x09,0x07),
	(0x0a,0x08,0x07), (0x09,0x07,0x07), (0x08,0x07,0x07), (0x06,0x06,0x06),
	(0x22,0x2f,0x1d), (0x1d,0x2b,0x18), (0x18,0x27,0x13), (0x14,0x24,0x0f),
	(0x11,0x20,0x0b), (0x0d,0x1d,0x08), (0x0a,0x19,0x05), (0x08,0x16,0x03),
	(0x3f,0x3f,0x1c), (0x3f,0x3d,0x1b), (0x3f,0x3a,0x1a), (0x3f,0x38,0x19),
	(0x3f,0x36,0x18), (0x3f,0x34,0x18), (0x3f,0x30,0x16), (0x3d,0x2d,0x14),
	(0x3b,0x2b,0x12), (0x39,0x25,0x0c), (0x35,0x1e,0x04), (0x31,0x18,0x00),
	(0x2d,0x12,0x00), (0x29,0x0e,0x00), (0x26,0x0a,0x00), (0x22,0x06,0x00),
	(0x2c,0x2c,0x3f), (0x25,0x25,0x39), (0x1f,0x1f,0x33), (0x1a,0x1a,0x2d),
	(0x15,0x15,0x27), (0x10,0x10,0x21), (0x0c,0x0c,0x1b), (0x09,0x09,0x16),
	(0x3f,0x00,0x00), (0x34,0x00,0x00), (0x29,0x00,0x00), (0x1f,0x00,0x00),
	(0x3f,0x00,0x3f), (0x3f,0x00,0x3f), (0x3f,0x00,0x3f), (0x3f,0x00,0x3f),
	(0x37,0x3d,0x3f), (0x34,0x3b,0x3e), (0x33,0x39,0x3d), (0x30,0x37,0x3d),
	(0x2e,0x35,0x3c), (0x2c,0x33,0x3b), (0x2a,0x31,0x3b), (0x28,0x2f,0x3a),
	(0x27,0x2c,0x39), (0x25,0x2a,0x39), (0x22,0x26,0x34), (0x1f,0x23,0x30),
	(0x1c,0x20,0x2b), (0x19,0x1c,0x27), (0x16,0x19,0x22), (0x13,0x16,0x1e),
	(0x39,0x3c,0x3f), (0x35,0x39,0x3d), (0x32,0x36,0x3b), (0x2f,0x34,0x39),
	(0x2b,0x31,0x37), (0x28,0x2f,0x35), (0x26,0x2d,0x33), (0x23,0x2b,0x31),
	(0x21,0x29,0x31), (0x1e,0x28,0x2f), (0x1c,0x27,0x2e), (0x1a,0x25,0x2d),
	(0x18,0x24,0x2c), (0x15,0x23,0x2b), (0x14,0x22,0x2a), (0x12,0x21,0x29),
	(0x3f,0x3f,0x3f), (0x31,0x31,0x32), (0x28,0x28,0x29), (0x20,0x20,0x21),
	(0x18,0x18,0x19), (0x00,0x32,0x00), (0x3f,0x3f,0x00), (0x3f,0x2f,0x00),
	(0x3f,0x1f,0x00), (0x3f,0x00,0x00), (0x2f,0x00,0x00), (0x33,0x33,0x3f),
	(0x26,0x26,0x3f), (0x19,0x19,0x3f), (0x00,0x00,0x3f), (0x3f,0x3f,0x3f),
]

# Image *load(const char *input, const char *palatte, int *n)
# {
# 	assert(sizeof(BYTE)==1 && sizeof(WORD)==2 && sizeof(LONGINT)==4);
	
def load(input, palatte):
# 	Image *output = NULL;
# 	LONGINT i = 1, imageSize = 0, d, s, k, j, x, y, w, h;
    i = 1
    imageSize = 0
    d = 0
    s = 0
    k = 0
    j = 0
    x = 0
    y = 0
    w = 0
    h = 0
# 	FILE *file = NULL;
    file = None
# 	FileHeader fileHeader;
# 	ImageHeader *pImageHeader = NULL;
    pImageHeader = None
# 	ImageData *imageDatas = NULL;
    imageDatas = None
# 	BYTE *imageData = NULL;
    imageData = None

# 	file = fopen(palatte, "rb");
# 	if(!file) perror(palatte);
# 	fread((BYTE*)defaultPalatte,3*sizeof(BYTE),256,file);
# 	fclose(file);
    with open(palatte, "rb") as file:
        for i in range(256):
            defaultPalatte[i] = struct.unpack(f"{3 * BYTE}B", file.read(3 * BYTE))

# 	file = fopen(input, "rb");
# 	if(!file) perror(input);
    with open(input, "rb") as file:
# 	fread(&fileHeader, sizeof(fileHeader), 1, file);
        check, width, height, num = struct.unpack("<2H2H", file.read(struct.calcsize("<2H2H")))
    
        fileHeader = FileHeader(check, width, height, num)

    # 	if(!(fileHeader.width && fileHeader.height))
    # 		perror("Zero size.\n");
        if fileHeader.width == 0 or fileHeader.height == 0:
            raise Exception("Zero size.")
        
    # 	if(!fileHeader.num)
    # 		perror("Zero number of images.\n");
        if fileHeader.num == 0:
            raise Exception("Zero number of images.")
        
    # 	if(fileHeader.check)
    # 		perror("Check nonzero.\n");
        if fileHeader.check != 0:
            raise Exception("Check nonzero. This is not a valid file.")

    # 	imageDatas = (ImageData*)malloc(fileHeader.num * sizeof(ImageData));
    # 	for(i = 0; i < fileHeader.num; i++)
    # 		fread(&imageDatas[i].header, sizeof(ImageHeader), 1, file);
        imageDatas = [ImageData(ImageHeader(*struct.unpack("<4H8B2I", file.read(struct.calcsize("<4H8B2I"))))) for _ in range(fileHeader.num)]

    # 	*n = fileHeader.num;
    # 	output = (Image*)malloc((*n) * sizeof(Image));
        output = [Image() for _ in range(fileHeader.num)]

    # 	for(i = 0; i < *n; i++)
    # 	{
        for i in range(fileHeader.num):
    # 		output[i].w = fileHeader.width;
    # 		output[i].h = fileHeader.height;
    # 		pImageHeader = &imageDatas[i].header;
            output[i].w = fileHeader.width
            output[i].h = fileHeader.height
            imageDatas[i].data = bytearray(output[i].w * output[i].h)
    # 		if(pImageHeader->compression == 1)
    # 			imageSize = pImageHeader->w * pImageHeader->h;
            if imageDatas[i].header.compression == 1:
                imageSize = imageDatas[i].header.w * imageDatas[i].header.h
    # 		else
    # 		{
    # 			if(i == *n - 1)
    # 			{
    # 				fseek(file,0L,SEEK_END);
    # 				imageSize = ftell(file) - pImageHeader->offset;
    # 			}
            else:
                if i == fileHeader.num - 1:
                    file.seek(0, 2)
                    imageSize = file.tell() - imageDatas[i].header.offset
    # 			else
    # 			{
                else:
    # 				imageSize = imageDatas[i+1].header.offset - pImageHeader->offset;
                    imageSize = imageDatas[i + 1].header.offset - imageDatas[i].header.offset
    # 				if(imageSize <= 0)
    # 				{
    # 					fseek(file,0L,SEEK_END);
    # 					imageSize = ftell(file) - pImageHeader->offset;
    # 					*n = i+1;
    # 				}
                    if imageSize <= 0:
                        file.seek(0, 2)
                        imageSize = file.tell() - imageDatas[i].header.offset
    # 			}
    # 		}


    # 		fseek(file,pImageHeader->offset,SEEK_SET);
    # 		allocImageData(&imageDatas[i]);
    # 		imageData = (BYTE*)malloc(imageSize * sizeof(BYTE));
    # 		fread(imageData,sizeof(BYTE),imageSize,file);
            file.seek(imageDatas[i].header.offset, 0)
            imageData = bytearray(imageSize)
            file.readinto(imageData)

    # 		if(pImageHeader->compression == 2)
    # 			decompress2(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
    # 		if(pImageHeader->compression == 3)
    # 			decompress3(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
    # 		else
    # 			decompress1(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
            if imageDatas[i].header.compression == 2:
                decompress2(imageDatas[i].data, imageData, imageDatas[i].header.w, imageDatas[i].header.h)
            elif imageDatas[i].header.compression == 3:
                decompress3(imageDatas[i].data, imageData, imageDatas[i].header.w, imageDatas[i].header.h)
            else:
                decompress1(imageDatas[i].data, imageData, imageDatas[i].header.w, imageDatas[i].header.h)
    # 		output[i].data = (BYTE*)malloc(output[i].w * output[i].h * 4);
            output[i].data = bytearray(output[i].w * output[i].h * 4)
    # 		x = imageDatas[i].header.x;
    # 		y = imageDatas[i].header.y;
    # 		w = imageDatas[i].header.w;
    # 		h = imageDatas[i].header.h;
            x = imageDatas[i].header.x
            y = imageDatas[i].header.y
            w = imageDatas[i].header.w
            h = imageDatas[i].header.h
    # 		for(k = 0; k < h; k++)
    # 		{
    # 			for(j = 0; j < w; j++)
    # 			{
            for k in range(h):
                for j in range(w):
    # 				s = k * w + j;
    # 				d = ((k + y) * output[i].w + x + j) * 4;
    # 				output[i].data[d]   = defaultPalatte[imageDatas[i].data[s]][0]*4+3;
    # 				output[i].data[d+1] = defaultPalatte[imageDatas[i].data[s]][1]*4+3;
    # 				output[i].data[d+2] = defaultPalatte[imageDatas[i].data[s]][2]*4+3;
    # 				if(imageDatas[i].data[s]) output[i].data[d+3] = 255;
                    s = k * w + j
                    d = ((k + y) * output[i].w + x + j) * 4
                    output[i].data[d] = defaultPalatte[imageDatas[i].data[s]][0] * 4 + 3
                    output[i].data[d + 1] = defaultPalatte[imageDatas[i].data[s]][1] * 4 + 3
                    output[i].data[d + 2] = defaultPalatte[imageDatas[i].data[s]][2] * 4 + 3
                    if imageDatas[i].data[s] != 0:
                        output[i].data[d + 3] = 255
    # 			}
    # 		}
    # 	}
# 	for(i = 0; i < *n; i++)
# 		freeImageData(&imageDatas[i]);
# 	for(i = *n; i < *n; i++)
# 		free(output[i].data);
# 	free(imageDatas);
# 	fclose(file);
	
# 	return output;
# }
    return output

if __name__ == "__main__":
    print("This is a module, not a script.")
    print("Use 'import shp' to use it.")
    exit(1)