#! This file is generated by ChatGPT and is not
#  working for now. Need going through and revision.

#define MAX_FILE_NAME 256

# typedef unsigned char BYTE;
# typedef short int WORD;
# typedef int LONGINT;

# void freeImageData(ImageData *imageData)
# {
# 	free(imageData->data);
# 	imageData->data = NULL;
# }

# BYTE defaultPalatte[][3] =
# {
# 	{0x00,0x00,0x00}, {0x2a,0x00,0x2a}, {0x00,0x2a,0x2a}, {0x00,0x2a,0x00},
# 	{0x15,0x3f,0x15}, {0x3f,0x3f,0x15}, {0x3f,0x15,0x15}, {0x2a,0x15,0x00},
# 	{0x2a,0x00,0x00}, {0x15,0x3f,0x3f}, {0x14,0x14,0x3f}, {0x00,0x00,0x2a},
# 	{0x00,0x00,0x00}, {0x15,0x15,0x15}, {0x2a,0x2a,0x2a}, {0x3f,0x3f,0x3f},
# 	{0x3f,0x00,0x00}, {0x3b,0x00,0x00}, {0x37,0x00,0x00}, {0x34,0x00,0x00},
# 	{0x30,0x00,0x00}, {0x2c,0x00,0x00}, {0x29,0x00,0x00}, {0x25,0x00,0x00},
# 	{0x21,0x00,0x00}, {0x1e,0x00,0x00}, {0x1a,0x00,0x00}, {0x16,0x00,0x00},
# 	{0x13,0x00,0x00}, {0x0f,0x00,0x00}, {0x0b,0x00,0x00}, {0x08,0x00,0x00},
# 	{0x3f,0x3f,0x3f}, {0x3d,0x3d,0x3d}, {0x3b,0x3b,0x3b}, {0x38,0x38,0x38},
# 	{0x36,0x36,0x36}, {0x34,0x34,0x34}, {0x32,0x32,0x32}, {0x30,0x30,0x30},
# 	{0x2e,0x2e,0x2e}, {0x2c,0x2c,0x2c}, {0x2a,0x2a,0x2a}, {0x28,0x28,0x28},
# 	{0x26,0x26,0x26}, {0x24,0x24,0x24}, {0x22,0x22,0x22}, {0x20,0x20,0x20},
# 	{0x1e,0x1e,0x1e}, {0x1c,0x1c,0x1c}, {0x1a,0x1a,0x1a}, {0x18,0x18,0x18},
# 	{0x15,0x15,0x15}, {0x13,0x13,0x13}, {0x11,0x11,0x11}, {0x0f,0x0f,0x0f},
# 	{0x0d,0x0d,0x0d}, {0x0b,0x0b,0x0b}, {0x09,0x09,0x09}, {0x07,0x07,0x07},
# 	{0x05,0x05,0x05}, {0x03,0x03,0x03}, {0x01,0x01,0x01}, {0x00,0x00,0x00},
# 	{0x34,0x34,0x2e}, {0x31,0x31,0x2b}, {0x2e,0x2e,0x28}, {0x2b,0x2b,0x25},
# 	{0x28,0x28,0x22}, {0x25,0x25,0x1f}, {0x22,0x22,0x1c}, {0x1f,0x1f,0x19},
# 	{0x1c,0x1c,0x16}, {0x19,0x19,0x13}, {0x16,0x16,0x10}, {0x13,0x13,0x0d},
# 	{0x10,0x10,0x0a}, {0x0d,0x0d,0x07}, {0x0a,0x0a,0x04}, {0x07,0x07,0x01},
# 	{0x37,0x37,0x3d}, {0x34,0x34,0x3a}, {0x31,0x31,0x37}, {0x2e,0x2e,0x34},
# 	{0x2b,0x2b,0x31}, {0x28,0x28,0x2e}, {0x25,0x25,0x2b}, {0x22,0x22,0x28},
# 	{0x1f,0x1f,0x25}, {0x1c,0x1c,0x22}, {0x19,0x19,0x1f}, {0x16,0x16,0x1c},
# 	{0x13,0x13,0x19}, {0x10,0x10,0x16}, {0x0d,0x0d,0x13}, {0x0a,0x0a,0x10},
# 	{0x3b,0x2f,0x2b}, {0x38,0x2c,0x28}, {0x35,0x29,0x25}, {0x32,0x26,0x22},
# 	{0x2f,0x23,0x1f}, {0x2c,0x20,0x1c}, {0x29,0x1d,0x19}, {0x26,0x1a,0x16},
# 	{0x23,0x17,0x13}, {0x20,0x14,0x10}, {0x1d,0x11,0x0d}, {0x1a,0x0e,0x0a},
# 	{0x17,0x0b,0x07}, {0x14,0x08,0x04}, {0x11,0x05,0x01}, {0x0d,0x01,0x00},
# 	{0x22,0x20,0x16}, {0x20,0x1e,0x15}, {0x1e,0x1d,0x14}, {0x1d,0x1b,0x13},
# 	{0x1c,0x1a,0x12}, {0x1a,0x18,0x11}, {0x18,0x16,0x10}, {0x16,0x14,0x0f},
# 	{0x14,0x12,0x0e}, {0x12,0x10,0x0c}, {0x0e,0x0e,0x0a}, {0x0c,0x0c,0x09},
# 	{0x0b,0x0b,0x08}, {0x0a,0x0a,0x07}, {0x08,0x08,0x05}, {0x06,0x06,0x03},
# 	{0x35,0x2f,0x1e}, {0x33,0x2d,0x1c}, {0x31,0x2b,0x1c}, {0x2f,0x29,0x1a},
# 	{0x2b,0x27,0x1a}, {0x29,0x25,0x18}, {0x27,0x23,0x16}, {0x25,0x21,0x14},
# 	{0x23,0x1e,0x14}, {0x21,0x1c,0x12}, {0x1e,0x1a,0x10}, {0x1c,0x18,0x0f},
# 	{0x1a,0x18,0x12}, {0x19,0x17,0x11}, {0x18,0x16,0x10}, {0x17,0x15,0x10},
# 	{0x2f,0x24,0x0f}, {0x2c,0x23,0x0e}, {0x29,0x21,0x0e}, {0x26,0x1e,0x0e},
# 	{0x23,0x1c,0x0e}, {0x21,0x1b,0x0e}, {0x1e,0x19,0x0e}, {0x1c,0x17,0x0c},
# 	{0x1b,0x16,0x0b}, {0x1a,0x15,0x0b}, {0x19,0x14,0x0a}, {0x18,0x13,0x0a},
# 	{0x17,0x12,0x0a}, {0x16,0x12,0x0a}, {0x15,0x11,0x0a}, {0x13,0x10,0x0a},
# 	{0x11,0x0e,0x09}, {0x0f,0x0d,0x08}, {0x0d,0x0b,0x08}, {0x0b,0x09,0x07},
# 	{0x0a,0x08,0x07}, {0x09,0x07,0x07}, {0x08,0x07,0x07}, {0x06,0x06,0x06},
# 	{0x22,0x2f,0x1d}, {0x1d,0x2b,0x18}, {0x18,0x27,0x13}, {0x14,0x24,0x0f},
# 	{0x11,0x20,0x0b}, {0x0d,0x1d,0x08}, {0x0a,0x19,0x05}, {0x08,0x16,0x03},
# 	{0x3f,0x3f,0x1c}, {0x3f,0x3d,0x1b}, {0x3f,0x3a,0x1a}, {0x3f,0x38,0x19},
# 	{0x3f,0x36,0x18}, {0x3f,0x34,0x18}, {0x3f,0x30,0x16}, {0x3d,0x2d,0x14},
# 	{0x3b,0x2b,0x12}, {0x39,0x25,0x0c}, {0x35,0x1e,0x04}, {0x31,0x18,0x00},
# 	{0x2d,0x12,0x00}, {0x29,0x0e,0x00}, {0x26,0x0a,0x00}, {0x22,0x06,0x00},
# 	{0x2c,0x2c,0x3f}, {0x25,0x25,0x39}, {0x1f,0x1f,0x33}, {0x1a,0x1a,0x2d},
# 	{0x15,0x15,0x27}, {0x10,0x10,0x21}, {0x0c,0x0c,0x1b}, {0x09,0x09,0x16},
# 	{0x3f,0x00,0x00}, {0x34,0x00,0x00}, {0x29,0x00,0x00}, {0x1f,0x00,0x00},
# 	{0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f},
# 	{0x37,0x3d,0x3f}, {0x34,0x3b,0x3e}, {0x33,0x39,0x3d}, {0x30,0x37,0x3d},
# 	{0x2e,0x35,0x3c}, {0x2c,0x33,0x3b}, {0x2a,0x31,0x3b}, {0x28,0x2f,0x3a},
# 	{0x27,0x2c,0x39}, {0x25,0x2a,0x39}, {0x22,0x26,0x34}, {0x1f,0x23,0x30},
# 	{0x1c,0x20,0x2b}, {0x19,0x1c,0x27}, {0x16,0x19,0x22}, {0x13,0x16,0x1e},
# 	{0x39,0x3c,0x3f}, {0x35,0x39,0x3d}, {0x32,0x36,0x3b}, {0x2f,0x34,0x39},
# 	{0x2b,0x31,0x37}, {0x28,0x2f,0x35}, {0x26,0x2d,0x33}, {0x23,0x2b,0x31},
# 	{0x21,0x29,0x31}, {0x1e,0x28,0x2f}, {0x1c,0x27,0x2e}, {0x1a,0x25,0x2d},
# 	{0x18,0x24,0x2c}, {0x15,0x23,0x2b}, {0x14,0x22,0x2a}, {0x12,0x21,0x29},
# 	{0x3f,0x3f,0x3f}, {0x31,0x31,0x32}, {0x28,0x28,0x29}, {0x20,0x20,0x21},
# 	{0x18,0x18,0x19}, {0x00,0x32,0x00}, {0x3f,0x3f,0x00}, {0x3f,0x2f,0x00},
# 	{0x3f,0x1f,0x00}, {0x3f,0x00,0x00}, {0x2f,0x00,0x00}, {0x33,0x33,0x3f},
# 	{0x26,0x26,0x3f}, {0x19,0x19,0x3f}, {0x00,0x00,0x3f}, {0x3f,0x3f,0x3f}
# };

# Image *load(const char *input, const char *palatte, int *n)
# {
# 	assert(sizeof(BYTE)==1 && sizeof(WORD)==2 && sizeof(LONGINT)==4);
	
# 	Image *output = NULL;
# 	LONGINT i = 1, imageSize = 0, d, s, k, j, x, y, w, h;
# 	FILE *file = NULL;
# 	FileHeader fileHeader;
# 	ImageHeader *pImageHeader = NULL;
# 	ImageData *imageDatas = NULL;
# 	BYTE *imageData = NULL;
	
# 	file = fopen(palatte, "rb");
# 	if(!file) perror(palatte);
# 	fread((BYTE*)defaultPalatte,3*sizeof(BYTE),256,file);
# 	fclose(file);

# 	file = fopen(input, "rb");
# 	if(!file) perror(input);
	
# 	fread(&fileHeader, sizeof(fileHeader), 1, file);
	
# 	if(fileHeader.check)
# 		perror("Check nonzero.\n");
	
# 	if(!(fileHeader.width && fileHeader.height))
# 		perror("Zero size.\n");
	
# 	if(!fileHeader.num)
# 		perror("Zero number of images.\n");
	
# 	imageDatas = (ImageData*)malloc(fileHeader.num * sizeof(ImageData));
	
# 	for(i = 0; i < fileHeader.num; i++)
# 		fread(&imageDatas[i].header, sizeof(ImageHeader), 1, file);
	
	
# 	*n = fileHeader.num;
# 	output = (Image*)malloc((*n) * sizeof(Image));

# 	for(i = 0; i < *n; i++)
# 	{
# 		output[i].w = fileHeader.width;
# 		output[i].h = fileHeader.height;
# 		pImageHeader = &imageDatas[i].header;
		
# 		if(pImageHeader->compression == 1)
# 			imageSize = pImageHeader->w * pImageHeader->h;
# 		else
# 		{
# 			if(i == *n - 1)
# 			{
# 				fseek(file,0L,SEEK_END);
# 				imageSize = ftell(file) - pImageHeader->offset;
# 			}
# 			else
# 			{
# 				imageSize = imageDatas[i+1].header.offset - pImageHeader->offset;
# 				if(imageSize <= 0)
# 				{
# 					fseek(file,0L,SEEK_END);
# 					imageSize = ftell(file) - pImageHeader->offset;
# 					*n = i+1;
# 				}
# 			}
# 		}

# 		fseek(file,pImageHeader->offset,SEEK_SET);
# 		allocImageData(&imageDatas[i]);
# 		imageData = (BYTE*)malloc(imageSize * sizeof(BYTE));
# 		fread(imageData,sizeof(BYTE),imageSize,file);
# 		if(pImageHeader->compression == 2)
# 			decompress2(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
# 		if(pImageHeader->compression == 3)
# 			decompress3(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
# 		else
# 			decompress1(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);

# 		output[i].data = (BYTE*)malloc(output[i].w * output[i].h * 4);
# 		x = imageDatas[i].header.x;
# 		y = imageDatas[i].header.y;
# 		w = imageDatas[i].header.w;
# 		h = imageDatas[i].header.h;
# 		for(k = 0; k < h; k++)
# 		{
# 			for(j = 0; j < w; j++)
# 			{
# 				s = k * w + j;
# 				d = ((k + y) * output[i].w + x + j) * 4;
# 				output[i].data[d]   = defaultPalatte[imageDatas[i].data[s]][0]*4+3;
# 				output[i].data[d+1] = defaultPalatte[imageDatas[i].data[s]][1]*4+3;
# 				output[i].data[d+2] = defaultPalatte[imageDatas[i].data[s]][2]*4+3;
# 				if(imageDatas[i].data[s]) output[i].data[d+3] = 255;
# 			}
# 		}
# 		free(imageData);
# 	}
		
# 	for(i = 0; i < *n; i++)
# 		freeImageData(&imageDatas[i]);
# 	for(i = *n; i < *n; i++)
# 		free(output[i].data);
# 	free(imageDatas);
# 	fclose(file);
	
# 	return output;
# }

# static PyObject *
# shpload(PyObject *self, PyObject *args)
# {
# 	const char *input, *pal;
# 	int n, i;
# 	Image *output;
# 	PyObject *pyList = NULL, *item = NULL;
# 	if(!PyArg_ParseTuple(args,"ss",&input,&pal))
# 		return NULL;
# 	output = load(input,pal,&n);
# 	if(n == 0) return Py_BuildValue("");
# 	pyList = PyList_New(n+1);
# 	item = PyTuple_New(2);
# 	PyTuple_SetItem(item,0,PyLong_FromLong(output[0].w));
# 	PyTuple_SetItem(item,1,PyLong_FromLong(output[0].h));
# 	PyList_SetItem(pyList,0,item);
# 	for(i = 0; i < n; i++)
# 	{
# 		item = PyByteArray_FromStringAndSize((char*)(output[i].data),
# 			output[i].w * output[i].h * 4);
# 		PyList_SetItem(pyList,i+1,item);
# 	}
# 	for(i = 0; i < n; i++)
# 		free(output[i].data);
# 	free(output);
# 	return pyList;
# }

# static PyMethodDef ShpMethods[] = {
# 	{"load", shpload, METH_VARARGS, "Load a shp file."},
# 	{NULL,NULL,0,NULL}
# };

# static struct PyModuleDef moduledef = {
#   PyModuleDef_HEAD_INIT,
#   "shpfile",     /* m_name */
#   "A python module for loading shp files",  /* m_doc */
#   -1,                  /* m_size */
#   ShpMethods,    /* m_methods */
#   NULL,                /* m_reload */
#   NULL,                /* m_traverse */
#   NULL,                /* m_clear */
#   NULL,                /* m_free */
# };

# PyMODINIT_FUNC
# PyInit_shpfile()
# {
#   PyObject *m;

#   m = PyModule_Create(&moduledef);
#   if (m == NULL)
#     return NULL;
#   else
#     return m;
# }

# int main(int argc, char *argv[])
# {
#   Py_SetProgramName(argv[0]);

#   /* Initialize the Python interpreter.  Required. */
#   Py_Initialize();

#   /* Add a static module */
#   PyInit_shpfile();

# 	return 0;
# }


import struct

MAX_FILE_NAME = 256

BYTE = 1
WORD = 2
LONGINT = 4


# typedef struct Color{
# 	BYTE c[4];
# } Color;

class Color:
    def __init__(self):
        self.c = [0] * 4

# typedef struct FileHeader{
# 	WORD check;
# 	WORD width;
# 	WORD height;
# 	WORD num;
# } FileHeader;

class FileHeader:
    def __init__(self):
        self.check = 0
        self.width = 0
        self.height = 0
        self.num = 0

# typedef struct ImageHeader{
# 	WORD x,y,w,h;
# 	BYTE compression;
# 	BYTE align[3];
# 	Color transparent;
# 	LONGINT zero,offset;
# } ImageHeader;

class ImageHeader:
    def __init__(self):
        self.x = 0
        self.y = 0
        self.w = 0
        self.h = 0
        self.compression = 0
        self.align = [0] * 3
        self.transparent = Color()
        self.zero = 0
        self.offset = 0

# typedef struct ImageData{
# 	ImageHeader header;
# 	BYTE * data;
# } ImageData;

class ImageData:
    def __init__(self):
        self.header = ImageHeader()
        self.data = None

# typedef struct Image{
# 	LONGINT w,h;
# 	BYTE *data;
# } Image;

class Image:
    def __init__(self):
        self.w = 0
        self.h = 0
        self.data = None

# void allocImageData(ImageData *imageData)
# {
# 	LONGINT size = imageData->header.w * imageData->header.h;
# 	imageData->data = (BYTE*)malloc(size * sizeof(LONGINT));
# }

def allocImageData(imageData):
    size = imageData.header.w * imageData.header.h
    imageData.data = [0] * (size * LONGINT)

# void decompress1(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
# 	memcpy(dst,src,w*h);
# }

def decompress1(dst, src, w, h):
    dst[:w*h] = src[:w*h]

# void decompress2(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
	
# }

def decompress2(dst, src, w, h):
    pass

# 		for(i = 0; i < count; i++)
# 		{
# 			v = *psrc++;
# 			if(v)
# 			{
# 				*pdst++ = v;
# 				x++;
# 			}
# 			else
# 			{
# 				v = *psrc++;
# 				i++;
# 				while(v > 0 && x < w)
# 				{
# 					*pdst++ = 0;
# 					x++;
# 					v--;
# 				}
# 			}
# 		}
# 		assert(x == w);
# 	}
# }

# void decompress3(BYTE *dst, BYTE *src, WORD w, WORD h)
# {
def decompress3(dst, src, w, h):
# 	BYTE *psrc = src, *pdst = dst;
    psrc = 0
    pdst = 0
# 	BYTE v;
    v = 0
# 	WORD pos, count, x, y, i;
    pos = 0
    count = 0
    x = 0
    y = 0
    i = 0
# 	for(y = 0; y < h; y++)
# 	{
    for y in range(h):
# 		pos = *((WORD*)psrc);
# 		count = pos-2;
# 		psrc += 2;
# 		x = 0;
        pos = struct.unpack_from('<H', src, psrc)[0]
        count = pos - 2
        psrc += 2
        x = 0
        for i in range(count):
            v = psrc[0]
            psrc += 1
            if v:
                pdst[0] = v
                pdst += 1
                x += 1
            else:
                v = psrc[0]
                psrc += 1
                i += 1
                while v > 0 and x < w:
                    pdst[0] = 0
                    pdst += 1
                    x += 1
                    v -= 1

defaultPalatte = [
	(0x00,0x00,0x00), (0x2a,0x00,0x2a), (0x00,0x2a,0x2a), (0x00,0x2a,0x00),
	(0x15,0x3f,0x15), (0x3f,0x3f,0x15), (0x3f,0x15,0x15), (0x2a,0x15,0x00),
	(0x2a,0x00,0x00), (0x15,0x3f,0x3f), (0x14,0x14,0x3f), (0x00,0x00,0x2a),
	(0x00,0x00,0x00), (0x15,0x15,0x15), (0x2a,0x2a,0x2a), (0x3f,0x3f,0x3f),
	(0x3f,0x00,0x00), (0x3b,0x00,0x00), (0x37,0x00,0x00), (0x34,0x00,0x00),
	(0x30,0x00,0x00), (0x2c,0x00,0x00), (0x29,0x00,0x00), (0x25,0x00,0x00),
	(0x21,0x00,0x00), (0x1e,0x00,0x00), (0x1a,0x00,0x00), (0x16,0x00,0x00),
	(0x13,0x00,0x00), (0x0f,0x00,0x00), (0x0b,0x00,0x00), (0x08,0x00,0x00),
	(0x3f,0x3f,0x3f), (0x3d,0x3d,0x3d), (0x3b,0x3b,0x3b), (0x38,0x38,0x38),
	(0x36,0x36,0x36), (0x34,0x34,0x34), (0x32,0x32,0x32), (0x30,0x30,0x30),
	(0x2e,0x2e,0x2e), (0x2c,0x2c,0x2c), (0x2a,0x2a,0x2a), (0x28,0x28,0x28),
	(0x26,0x26,0x26), (0x24,0x24,0x24), (0x22,0x22,0x22), (0x20,0x20,0x20),
	(0x1e,0x1e,0x1e), (0x1c,0x1c,0x1c), (0x1a,0x1a,0x1a), (0x18,0x18,0x18),
	(0x15,0x15,0x15), (0x13,0x13,0x13), (0x11,0x11,0x11), (0x0f,0x0f,0x0f),
	(0x0d,0x0d,0x0d), (0x0b,0x0b,0x0b), (0x09,0x09,0x09), (0x07,0x07,0x07),
	(0x05,0x05,0x05), (0x03,0x03,0x03), (0x01,0x01,0x01), (0x00,0x00,0x00),
	(0x34,0x34,0x2e), (0x31,0x31,0x2b), (0x2e,0x2e,0x28), (0x2b,0x2b,0x25),
	(0x28,0x28,0x22), (0x25,0x25,0x1f), (0x22,0x22,0x1c), (0x1f,0x1f,0x19),
	(0x1c,0x1c,0x16), (0x19,0x19,0x13), (0x16,0x16,0x10), (0x13,0x13,0x0d),
	(0x10,0x10,0x0a), (0x0d,0x0d,0x07), (0x0a,0x0a,0x04), (0x07,0x07,0x01),
	(0x37,0x37,0x3d), (0x34,0x34,0x3a), (0x31,0x31,0x37), (0x2e,0x2e,0x34),
	(0x2b,0x2b,0x31), (0x28,0x28,0x2e), (0x25,0x25,0x2b), (0x22,0x22,0x28),
	(0x1f,0x1f,0x25), (0x1c,0x1c,0x22), (0x19,0x19,0x1f), (0x16,0x16,0x1c),
	(0x13,0x13,0x19), (0x10,0x10,0x16), (0x0d,0x0d,0x13), (0x0a,0x0a,0x10),
	(0x3b,0x2f,0x2b), (0x38,0x2c,0x28), (0x35,0x29,0x25), (0x32,0x26,0x22),
	(0x2f,0x23,0x1f), (0x2c,0x20,0x1c), (0x29,0x1d,0x19), (0x26,0x1a,0x16),
	(0x23,0x17,0x13), (0x20,0x14,0x10), (0x1d,0x11,0x0d), (0x1a,0x0e,0x0a),
	(0x17,0x0b,0x07), (0x14,0x08,0x04), (0x11,0x05,0x01), (0x0d,0x01,0x00),
	(0x22,0x20,0x16), (0x20,0x1e,0x15), (0x1e,0x1d,0x14), (0x1d,0x1b,0x13),
	(0x1c,0x1a,0x12), (0x1a,0x18,0x11), (0x18,0x16,0x10), (0x16,0x14,0x0f),
	(0x14,0x12,0x0e), (0x12,0x10,0x0c), (0x0e,0x0e,0x0a), (0x0c,0x0c,0x09),
	(0x0b,0x0b,0x08), (0x0a,0x0a,0x07), (0x08,0x08,0x05), (0x06,0x06,0x03),
	(0x35,0x2f,0x1e), (0x33,0x2d,0x1c), (0x31,0x2b,0x1c), (0x2f,0x29,0x1a),
	(0x2b,0x27,0x1a), (0x29,0x25,0x18), (0x27,0x23,0x16), (0x25,0x21,0x14),
	(0x23,0x1e,0x14), (0x21,0x1c,0x12), (0x1e,0x1a,0x10), (0x1c,0x18,0x0f),
	(0x1a,0x18,0x12), (0x19,0x17,0x11), (0x18,0x16,0x10), (0x17,0x15,0x10),
	(0x2f,0x24,0x0f), (0x2c,0x23,0x0e), (0x29,0x21,0x0e), (0x26,0x1e,0x0e),
	(0x23,0x1c,0x0e), (0x21,0x1b,0x0e), (0x1e,0x19,0x0e), (0x1c,0x17,0x0c),
	(0x1b,0x16,0x0b), (0x1a,0x15,0x0b), (0x19,0x14,0x0a), (0x18,0x13,0x0a),
	(0x17,0x12,0x0a), (0x16,0x12,0x0a), (0x15,0x11,0x0a), (0x13,0x10,0x0a),
	(0x11,0x0e,0x09), (0x0f,0x0d,0x08), (0x0d,0x0b,0x08), (0x0b,0x09,0x07),
	(0x0a,0x08,0x07), (0x09,0x07,0x07), (0x08,0x07,0x07), (0x06,0x06,0x06),
	(0x22,0x2f,0x1d), (0x1d,0x2b,0x18), (0x18,0x27,0x13), (0x14,0x24,0x0f),
	(0x11,0x20,0x0b), (0x0d,0x1d,0x08), (0x0a,0x19,0x05), (0x08,0x16,0x03),
	(0x3f,0x3f,0x1c), (0x3f,0x3d,0x1b), (0x3f,0x3a,0x1a), (0x3f,0x38,0x19),
	(0x3f,0x36,0x18), (0x3f,0x34,0x18), (0x3f,0x30,0x16), (0x3d,0x2d,0x14),
	(0x3b,0x2b,0x12), (0x39,0x25,0x0c), (0x35,0x1e,0x04), (0x31,0x18,0x00),
	(0x2d,0x12,0x00), (0x29,0x0e,0x00), (0x26,0x0a,0x00), (0x22,0x06,0x00),
	(0x2c,0x2c,0x3f), (0x25,0x25,0x39), (0x1f,0x1f,0x33), (0x1a,0x1a,0x2d),
	(0x15,0x15,0x27), (0x10,0x10,0x21), (0x0c,0x0c,0x1b), (0x09,0x09,0x16),
	(0x3f,0x00,0x00), (0x34,0x00,0x00), (0x29,0x00,0x00), (0x1f,0x00,0x00),
	(0x3f,0x00,0x3f), (0x3f,0x00,0x3f), (0x3f,0x00,0x3f), (0x3f,0x00,0x3f),
	(0x37,0x3d,0x3f), (0x34,0x3b,0x3e), (0x33,0x39,0x3d), (0x30,0x37,0x3d),
	(0x2e,0x35,0x3c), (0x2c,0x33,0x3b), (0x2a,0x31,0x3b), (0x28,0x2f,0x3a),
	(0x27,0x2c,0x39), (0x25,0x2a,0x39), (0x22,0x26,0x34), (0x1f,0x23,0x30),
	(0x1c,0x20,0x2b), (0x19,0x1c,0x27), (0x16,0x19,0x22), (0x13,0x16,0x1e),
	(0x39,0x3c,0x3f), (0x35,0x39,0x3d), (0x32,0x36,0x3b), (0x2f,0x34,0x39),
	(0x2b,0x31,0x37), (0x28,0x2f,0x35), (0x26,0x2d,0x33), (0x23,0x2b,0x31),
	(0x21,0x29,0x31), (0x1e,0x28,0x2f), (0x1c,0x27,0x2e), (0x1a,0x25,0x2d),
	(0x18,0x24,0x2c), (0x15,0x23,0x2b), (0x14,0x22,0x2a), (0x12,0x21,0x29),
	(0x3f,0x3f,0x3f), (0x31,0x31,0x32), (0x28,0x28,0x29), (0x20,0x20,0x21),
	(0x18,0x18,0x19), (0x00,0x32,0x00), (0x3f,0x3f,0x00), (0x3f,0x2f,0x00),
	(0x3f,0x1f,0x00), (0x3f,0x00,0x00), (0x2f,0x00,0x00), (0x33,0x33,0x3f),
	(0x26,0x26,0x3f), (0x19,0x19,0x3f), (0x00,0x00,0x3f), (0x3f,0x3f,0x3f),
]

def load(input, palatte):
    assert BYTE == 1 and WORD == 2 and LONGINT == 4

    output = None
    i = 1
    imageSize = 0
    d = 0
    s = 0
    k = 0
    j = 0
    x = 0
    y = 0
    w = 0
    h = 0
    file = None
    fileHeader = FileHeader()
    pImageHeader = None
    imageDatas = None
    imageData = None

    with open(palatte, "rb") as file:
        defaultPalatte[:] = struct.unpack(f"{3 * BYTE}B", file.read(3 * BYTE))

    with open(input, "rb") as file:
        fileHeader = FileHeader(*struct.unpack("<2H2H", file.read(struct.calcsize("<2H2H"))))

        if fileHeader.check:
            raise Exception("Check nonzero. This is not a valid file.")

        imageDatas = [ImageData() for _ in range(fileHeader.num)]
        pImageHeader = [ImageHeader() for _ in range(fileHeader.num)]

        for i in range(fileHeader.num):
            imageDatas[i].header = pImageHeader[i]
            pImageHeader[i] = ImageHeader(*struct.unpack("<4H6B4I", file.read(struct.calcsize("<4H6B4I"))))

            if pImageHeader[i].compression > 3:
                raise Exception("Invalid compression mode.")

            imageSize += pImageHeader[i].w * pImageHeader[i].h
            if pImageHeader[i].compression == 1:
                imageData = bytearray(pImageHeader[i].w * pImageHeader[i].h)
                file.readinto(imageData)
                decompress1(imageDatas[i].data, imageData, pImageHeader[i].w, pImageHeader[i].h)
            elif pImageHeader[i].compression == 2:
                imageData = bytearray(pImageHeader[i].w * pImageHeader[i].h)
                file.readinto(imageData)
                decompress2(imageDatas[i].data, imageData, pImageHeader[i].w, pImageHeader[i].h)
            elif pImageHeader[i].compression == 3:
                imageData = bytearray(pImageHeader[i].zero)
                file.readinto(imageData)
                decompress3(imageDatas[i].data, imageData, pImageHeader[i].w, pImageHeader[i].h)

        output = Image()
        output.w = fileHeader.width
        output.h = fileHeader.height
        output.data = bytearray(output.w * output.h)
        for i in range(fileHeader.num):
            for y in range(pImageHeader[i].h):
                for x in range(pImageHeader[i].w):
                    d = (y + pImageHeader[i].y) * output.w + x + pImageHeader[i].x
                    s = y * pImageHeader[i].w + x
                    output.data[d] = imageDatas[i].data[s]
        return output, fileHeader.num

def save(input, output, palatte):
    assert BYTE == 1 and WORD == 2 and LONGINT == 4

    fileHeader = FileHeader()
    fileHeader.check = 0
    fileHeader.width = input.w
    fileHeader.height= input.h
    fileHeader.num = 1
    pImageHeader = ImageHeader()
    pImageHeader.x = 0
    pImageHeader.y = 0
    pImageHeader.w = input.w
    pImageHeader.h = input.h
    pImageHeader.compression = 1
    pImageHeader.align = [0] * 3
    pImageHeader.transparent.c = [0] * 4
    pImageHeader.zero = 0
    pImageHeader.offset = 0
    imageData = ImageData()
    imageData.header = pImageHeader
    imageData.data = input.data

    with open(output, "wb") as file:
        file.write(struct.pack("<2H2H", fileHeader.check, fileHeader.width, fileHeader.height, fileHeader.num))
        file.write(struct.pack("<4H6B4I", pImageHeader.x, pImageHeader.y, pImageHeader.w, pImageHeader.h, pImageHeader.compression, pImageHeader.align[0], pImageHeader.align[1], pImageHeader.align[2], pImageHeader.transparent.c[0], pImageHeader.transparent.c[1], pImageHeader.transparent.c[2], pImageHeader.transparent.c[3], pImageHeader.zero, pImageHeader.offset))
        file.write(bytes(imageData.data))

    with open(palatte, "wb") as file:
        file.write(struct.pack(f"{3 * BYTE}B", *[color for colors in defaultPalatte for color in colors]))

def main():
    input = load("input.bmp", "palatte.bmp")
    save(input, "output.bmp", "palatte.bmp")

if __name__ == "__main__":
    main()
